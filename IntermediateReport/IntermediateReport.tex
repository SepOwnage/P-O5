\documentclass[a4paper]{article}
\usepackage{amssymb}
\usepackage{graphicx}

\title{H09M0A P\&D Embedded Systems and Multimedia}
\author{Seppe Iven - r0370830 \\ Koen Goetschalckx - r0375967}
\begin{document} 
\maketitle
\begin{center} Yu-Hui Huang, Johan Van Rompay, Hugo Van hamme
\end{center}

\section{Introduction}
This is an intermediate report about the matlab implementation of the P\&D assignment on subband coding, where a codec is implemented. The main techniques used to create such codec are subband filtering and adaptive quantisation, with the goal of compressing a stereo audio signal. This matlab implementation uses fixed point numbers and its parameters can be set in a flexible manner with the eye to optimal speech quality. \

TODO edit this paragraph to include all sections of the report:
This report contains a section on the main findings, an explanation about QMF filterbanks and the general matlab structure of the implementation of the assignment. It then explains the criteria for the optimal values of the parameters, followed by those values. Those values lead to a SNR and PESQ score for audio that has been encoded and decoded with this implementation.

\section{Main design specifications}
The following list contains the specifications that the design of the codec has to meet.

\begin{itemize}
\item It accepts stereo signals
\item The sampling frequency is 8 kHz
\item The bitrate is 24 kbit/s per channel codec, with good to very good speech quality
\item The implementation consists of a QMF tree-structured filterbank with polyphase implementation
\item An adaptive differential quantisation scheme should be used for every subband signal
\item The filterbank of the codec consists of a minimum of 4 subbands
\item The total delay of the coder and decoder must not exceed a certain threshold: the entire one way communication delay (ADC, coding, encryption, decryption, decoding, DAC) should be less than 150ms. This puts a maximum on the number of subbands, on the complexity of the filters and on the buffer size in the cryptography section. Note that the encryption and decryption functionality is provided by another group and is not a part of this assignment.

\end{itemize}

\section{Main findings}
Don' really know what to put here but the assignment said we need this section. Maybe this is an introduction/conclusion section?

\section{QMF and shizzle}
A Quadrature Mirror Filter, or QMF, is a special kind of filter that can be used to efficiently create a 2-way filter bank. Recursively applying QMFs will split the signal into more subbands. QMF filters have some special properties:
\begin{itemize}
\item if $H_0(z)$ is a QMF filter, then $H_1(z) = H_0(-z)$ has the frequency response of $H_0$ mirrored around $\pi/2$.
\item if $H_0(z)$ is a QMF filter, then analysis filters $H_0(z)$ and $H_1(z) = H_0(-z)$ and synthesis filters $F_0(z)=H_1(-z)=H_0(z)$ and $F_1(z)=-H_0(-z) = -H_1(z)$ form an alias-free filter bank.
\end{itemize}
The second property indicates that $H_0(z)$ alone can completely define an alias-free QMF filter bank. For the filter to be linear phase, this $H_0$ should be chosen symmetrical. Also, the filter should have an even amount of taps to avoid distortion at half the Nyquist frequency. The first property indicates that if $H_0$ is a good low-pass filter, then $H_1$ is a good high-pass filter.

Given these properties and constraints, a simple polyphase implementation for a QMF filter bank can be designed. Writing the polyphase decomposition of $H_0(z)$ as $E_0(z^2) + z^{-1} E_1(z^2)$ and the decomposition of $H_1(z)$ as $E_0(z^2) - z^{-1} E_1(z^2)$. This lead to an efficient implementation, as shown in figure \ref{fig:qmf}.

\begin{figure}[hbt]
\includegraphics[width = \textwidth]{qmf}
\caption{Polyphase implementation of QMF filter bank}
\label{fig:qmf}
\end{figure}

TODO: show figure

TODO: bron vermelden? http://www.hindawi.com/journals/isrn/2013/815619/
Type something about how QMF works (so it can be skipped in get\_subbands.m). Talk about how many bits per subband, how this equals 24k bit/s etc..
TODO figures e.g. input and output signals of QMF system
TODO zeggen dat onderste subbanden belangrijker blijken uit testen -> meer bits aan toekennen
TODO over hoe we eerst 5 subbanden hadden (want onderste zijn belangrijker dan de rest), maar we er eigenlijk 4 moesten doen volgens die assistent

\section{Adaptive differential quantisation and shizzle}
TODO foto'ke van adaptive differential maar beter dan die in onze tekst.
TODO delays implementeren want die afbeeding in het boek is ni goed 

After filtering into subbands, the data is now encoded with the adaptive differential quantisation scheme proposed in the assignment. The quantizer can be seen in figure \ref{fig:quantization} and the dequantizer in figure \ref{dequantization}. They contain the following signals:

\begin{itemize}
\item s(n) is the (serial) input signal
\item d(n) is the difference signal between the input signal and the prediction of the signal
\item z(n) is the quantized difference signal. This is also the output signal, hence the 'differential' in the name
\item d'(n) is the difference signal after quantization and dequantization. It thus resembles d(n) but is not exactly the same value
\item s'(n) is the sum of d'(n) and the prediction. It thus resembles s(n) but is not exactly the same value
\item s*(n) is the prediction of the next input signal 
\end{itemize}

As the name suggests, the stepsize is adaptive and based on the last values of d'(n) and a parameter $\phi$ TODO DAS NI PHI. The amount of values that influence the stepsize, is determined by the parameter 'buffer\_length'. Stepsize is calculated as follows:\\
$stepsize = round\_to\_zero(\phi*mean(abs(D'(n))))$
where D'(n) contains the last buffer\_length values of d'(n). \\
The reason that it uses d'(n) instead of d(n) is because the dequantizer only knows d'(n) and not d(n). For the same reason, the prediction is based on s'(n) and not in s(n). The prediction is a simple first order prediction, defined by the previous approximation of the signal s'(n) and a parameter $'\mu'$:\\
$s*(n) = \mu*s'(n-1)$.\\
The dequantizer can reconstruct s'(n) based on the z(n) it receives. It is thus lossy, since it cannot reconstruct s(n).



\begin{figure}[hbt]
\includegraphics[width = \textwidth]{Quantization.png}
\caption{The Adaptive Differential Quantization scheme}
\label{fig:quantization}
\end{figure}
\begin{figure}[hbt]
\includegraphics[width = \textwidth]{Dequantization.png}
\caption{The Adaptive Differential Dequantization scheme}
\label{fig:dequantization}
\end{figure}

\section{Matlab structure - Implementation overview}
This paper will now give a brief explanation of the matlab files that are used and their functionality.

TODO: Talk about all the scalings to make the numbers fit integers as much as possible etc

\subsection{generate\_some\_params.m}
This script can be run to generate the parameters that are used to call run.m

\subsection{run.m}
This is the main script that is used to divide an audio file into subbands, encode and decode those subbands, and synthesize them again to create an audio signal that closely resembles the original signal. Accepted audio files are .wav-files that are stereo or pairwise mono. The audio file that is used is that one named 'input.wav' TODO: Do we keep it this way or do we change input.wav to a parameter? 
\\
The input is scaled to a 16 bit integer. The input is then split into subbands by calling analysis.m. These subbands are first encoded by calling encoded.m and then decoded by calling decode.m. Finally, the subbands are combined by calling synthesis.m and the PESQ score for the reconstructed audio file is calculated by calling alignpesq.m	.

\subsection{analysis.m}
This matlab script mainly splits the stereo (or pairwise mono) channels into separate channels, and feeds splits them into subbands by calling get\_subbands.m.

\subsection{get\_subbands.m}
This script recursively splits an audio channel into its subbands. It does this by applying polyphase QMF filters, as has been explained earlier in this paper TODO Is this true?. These filters are generated with a script that is given with the assignment and defined by its parameters.
TODO: Does this script also check for clipping/overflow?
\subsection{encode.m}
This script uses an adaptive differential quantisation method to compress an input signal. Such method is covered in an earlier part of this paper. TODO: Is this true?
TODO: Does this script also check for clipping/overflow?

This file also checks for clipping of values greater than 16 bits.

\subsection{decode.m}
This script is the inverse of encode.m: it takes the output of the adaptive differential quantisation function and constructs the original input signal.

\subsection{synthesis.m}
This script is the inverse of get\_subbands.m: its input are the separate subbands and it combines (synthesizes) them using the same QMF filters. Todo: These filters are the same, right?

\subsection{alignpesq.m}
This script aligns the original audio and the processed audio, and calculates the pesq score with the scripts that are provided with the assignment.

\section{Criterion for optimal values}
From p127, we got the values for phi TODO we assumed gaussian distribution
Optimal values also includes: filter lengths etc just put here as many parameters as possible i guess
From the book: mu is fixed per fequency band. Estimate it such that the energy of the prediction error s(n) - mu*s(n-1) is minimized

\section{Optimal values of all controllable parameters}
TODO hier onze finale waarden ingeven en zeggen hoe we eraan komen (zie boek: sommige vanuit theorie, sommigen bruteforce)
TODO also zeggen dat we optimised hebben voor de combined shizzle omdat die ons beter lijkt dan voor één aparte; dan zeggen wat de optimale en de minst optimale pesq waarden zijn bij de verschillende .wav bestandjes
TODO zeggen dat deze waarden subject to change zijn en mogelijk niet onze finale waarden

\section{Final SNR \& PESQ}
TODO zeggen dat we SNR niet hebben gebruikt en daar een reden voor verzinnen bv pesq is beter

\section{Conclusion}
TODO spekken (zie taalgebruik van bossie) over alle secties die we behandeld hebben in deze paper
TODO zeggen dat we een goede maar niet finale matlab implementatie hebben (bv de deling die we nog aangepast hebben om op C te lijken; alsook dat onze final parameters nog niet final zijn maar subject to optimization)

\end{document}

TODO scan for codex instead of codec
TODO include total delay of code/encode: should be less than 150ms
TODO rechterdeel in run
TODO iets over delay?